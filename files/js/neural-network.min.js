/* neural-network.min.js SharkCoding */
const NeuralNetwork=function(){const r=(r,t)=>Math.random()*(t-r)+r;class t{constructor(t){this.weights=Array.from({length:t},(()=>r(-1,1))),this.bias=r(-1,1)}copy(){var r=new t(0);return r.weights=[...this.weights],r.bias=this.bias,r}activationFunc(r){return Math.tanh(r)}evaluate(r){var t,a;if(r.length==this.weights.length)return this.activationFunc((t=r,a=this.weights,t.map(((r,t)=>r*a[t])).reduce(((r,t)=>r+t))+this.bias))}static fromWeights(r,a){var s=new t(0);return r=[...r],a||(a=r.pop()),s.weights=r,s.bias=a,s}}class a{constructor(...r){let a;this.map=r,this.layers=[],r.forEach((r=>{a&&this.layers.push(Array.from({length:r},(()=>new t(a)))),a=r}))}copy(){var r=new a(this.map),t=[];return this.layers.forEach((r=>{t.push(Array.from(r,(r=>r.copy())))})),r.layers=t,newNet}evaluate(r){var t=[...r];return this.layers.forEach((r=>{t=Array.from(r,(r=>r.evaluate(t)))})),t}static fromLayers(r){var s=new a;return r.forEach((r=>{s.layers.push(Array.from(r,(r=>t.fromWeights(r))))})),s}}return a}();